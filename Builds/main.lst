   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 112               	.global	send_uart_char
 114               	send_uart_char:
 116               	.Ltext1:
   1:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** //
   2:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** //  sht.c
   3:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** //  avrSHT
   4:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** //
   5:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** //  Created by aercys on 10/08/16.
   6:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** //  Copyright Â© 2016 aercys. All rights reserved.
   7:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** //
   8:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
   9:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** #include <stdio.h>
  10:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
  11:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void initialize_transmisson() {
  12:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     /*
  13:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      * SHT11
  14:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      * Start Sequence
  15:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      *        __    __
  16:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      * SCK  _|  |__|  |__
  17:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      *      __       ____
  18:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      * DATA   |_____|
  19:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      *
  20:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      */
  21:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_out;
  22:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_high;
  23:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(2);
  24:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_high;
  25:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(2);
  26:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_low;
  27:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(2);
  28:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_low;
  29:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(8);
  30:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_high;
  31:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(2);
  32:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_high;
  33:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(2);
  34:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_low;
  35:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
  36:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
  37:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void send_command(uint8_t command) {
  38:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(4);
  39:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_out;                               // Enable data as output port
  40:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     
  41:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     for (int i = 0; i < 8; i++) {
  42:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         if (0x01 & (command >> (7-i))) {
  43:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             data_high;
  44:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         } else {
  45:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             data_low;
  46:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         }
  47:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         
  48:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         _delay_us(4);
  49:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_high;
  50:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         _delay_us(4);
  51:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_low;
  52:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         
  53:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         if (i == 7) {
  54:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             data_in;
  55:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             data_high;
  56:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             while ((PINB & (1 << DATA)));   // Wait for data line low
  57:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         }
  58:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     }
  59:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     
  60:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(4);
  61:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_high;
  62:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(4);
  63:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_low;
  64:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
  65:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
  66:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void reset() {
  67:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_out;
  68:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_high;
  69:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     
  70:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     for (int i = 0; i < 9; i++) {
  71:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         _delay_us(4);
  72:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_high;
  73:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         _delay_us(4);
  74:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_low;
  75:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     }
  76:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     initialize_transmisson();
  77:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
  78:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
  79:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
  80:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
  81:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** uint16_t read_data() {
  82:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     uint8_t dataL, dataH;
  83:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     uint16_t measured;
  84:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     dataL = 0x00;
  85:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     dataH = 0x00;
  86:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_in;
  87:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_high;
  88:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     
  89:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     while (PINB & (1<<DATA));
  90:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     //Start receiving MSB
  91:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     receiveBytes(&dataH);
  92:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     ack(); // ack() to start getting LSB
  93:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     //Start receiving LSB
  94:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     receiveBytes(&dataL);
  95:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     
  96:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     measured = (dataH << 8) | dataL;
  97:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     return measured;
  98:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
  99:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
 100:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** float calculateMeasuredData(uint16_t measuredData, uint8_t value) {
 101:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     float humiLin, tempLin;
 102:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     
 103:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     switch (value) {
 104:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         case humidity:
 105:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             humiLin = measuredData * 0.0405 - 2.8 * pow(10, -6) * pow(measuredData, 2) - 4;
 106:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             return humiLin;
 107:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             break;
 108:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         case temperature:
 109:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             tempLin = -40.00 + 0.01 * measuredData;
 110:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             return tempLin;
 111:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             break;
 112:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     }
 113:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     
 114:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     return 1;
 115:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
 116:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
 117:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
 118:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void serial_init() {
 119:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     /*
 120:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      *
 121:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      * Initialize UART,
 122:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      * 8 bit frame, 1 Stop Bit
 123:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      * No Parity
 124:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      *
 125:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****      */
 126:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     UCSR0B = (1 << TXEN0);
 127:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     UBRR0L = 51;
 128:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
 129:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
 130:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
 131:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void send_uart_char(unsigned char serial_data, FILE *stream) {
 118               	.LM0:
 119               	.LFBB1:
 120 0000 CF93      		push r28
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 1 */
 124               	.L__stack_usage = 1
 125 0002 C82F      		mov r28,r24
 132:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     if (serial_data == '\n') { // Send each byte until reached \n character
 127               	.LM1:
 128 0004 8A30      		cpi r24,lo8(10)
 129 0006 01F4      		brne .L4
 133:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         send_uart_char('\r', stream);
 131               	.LM2:
 132 0008 8DE0      		ldi r24,lo8(13)
 133 000a 0E94 0000 		call send_uart_char
 134               	.L4:
 134:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     }
 135:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     
 136:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     while (!(UCSR0A & (1 << UDRE0)));
 136               	.LM3:
 137 000e 8091 C000 		lds r24,192
 138 0012 85FF      		sbrs r24,5
 139 0014 00C0      		rjmp .L4
 137:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     UDR0 = serial_data;
 141               	.LM4:
 142 0016 C093 C600 		sts 198,r28
 143               	/* epilogue start */
 138:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
 145               	.LM5:
 146 001a CF91      		pop r28
 147 001c 0895      		ret
 149               	.Lscope1:
 151               	.global	initialize_transmisson
 153               	initialize_transmisson:
  11:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void initialize_transmisson() {
 155               	.LM6:
 156               	.LFBB2:
 157               	/* prologue: function */
 158               	/* frame size = 0 */
 159               	/* stack size = 0 */
 160               	.L__stack_usage = 0
  21:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_out;
 162               	.LM7:
 163 001e 83E0      		ldi r24,lo8(3)
 164 0020 84B9      		out 0x4,r24
  22:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_high;
 166               	.LM8:
 167 0022 289A      		sbi 0x5,0
 168               	.LBB49:
 169               	.LBB50:
 171               	.Ltext2:
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 173               	.LM9:
 174 0024 85E0      		ldi r24,lo8(5)
 175 0026 8A95      		1: dec r24
 176 0028 01F4      		brne 1b
 177 002a 0000      		nop
 178               	.LBE50:
 179               	.LBE49:
 181               	.Ltext3:
  24:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_high;
 183               	.LM10:
 184 002c 299A      		sbi 0x5,1
 185               	.LBB51:
 186               	.LBB52:
 188               	.Ltext4:
 190               	.LM11:
 191 002e 85E0      		ldi r24,lo8(5)
 192 0030 8A95      		1: dec r24
 193 0032 01F4      		brne 1b
 194 0034 0000      		nop
 195               	.LBE52:
 196               	.LBE51:
 198               	.Ltext5:
  26:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_low;
 200               	.LM12:
 201 0036 2898      		cbi 0x5,0
 202               	.LBB53:
 203               	.LBB54:
 205               	.Ltext6:
 207               	.LM13:
 208 0038 85E0      		ldi r24,lo8(5)
 209 003a 8A95      		1: dec r24
 210 003c 01F4      		brne 1b
 211 003e 0000      		nop
 212               	.LBE54:
 213               	.LBE53:
 215               	.Ltext7:
  28:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_low;
 217               	.LM14:
 218 0040 2998      		cbi 0x5,1
 219               	.LBB55:
 220               	.LBB56:
 222               	.Ltext8:
 224               	.LM15:
 225 0042 85E1      		ldi r24,lo8(21)
 226 0044 8A95      		1: dec r24
 227 0046 01F4      		brne 1b
 228 0048 0000      		nop
 229               	.LBE56:
 230               	.LBE55:
 232               	.Ltext9:
  30:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_high;
 234               	.LM16:
 235 004a 299A      		sbi 0x5,1
 236               	.LBB57:
 237               	.LBB58:
 239               	.Ltext10:
 241               	.LM17:
 242 004c 85E0      		ldi r24,lo8(5)
 243 004e 8A95      		1: dec r24
 244 0050 01F4      		brne 1b
 245 0052 0000      		nop
 246               	.LBE58:
 247               	.LBE57:
 249               	.Ltext11:
  32:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_high;
 251               	.LM18:
 252 0054 289A      		sbi 0x5,0
 253               	.LBB59:
 254               	.LBB60:
 256               	.Ltext12:
 258               	.LM19:
 259 0056 85E0      		ldi r24,lo8(5)
 260 0058 8A95      		1: dec r24
 261 005a 01F4      		brne 1b
 262 005c 0000      		nop
 263               	.LBE60:
 264               	.LBE59:
 266               	.Ltext13:
  34:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_low;
 268               	.LM20:
 269 005e 2998      		cbi 0x5,1
 270 0060 0895      		ret
 272               	.Lscope2:
 275               	.global	send_command
 277               	send_command:
  37:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void send_command(uint8_t command) {
 279               	.LM21:
 280               	.LFBB3:
 281               	/* prologue: function */
 282               	/* frame size = 0 */
 283               	/* stack size = 0 */
 284               	.L__stack_usage = 0
 285               	.LBB61:
 286               	.LBB62:
 288               	.Ltext14:
 290               	.LM22:
 291 0062 6AE0      		ldi r22,lo8(10)
 292 0064 6A95      		1: dec r22
 293 0066 01F4      		brne 1b
 294 0068 00C0      		rjmp .
 295               	.LBE62:
 296               	.LBE61:
 298               	.Ltext15:
  39:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_out;                               // Enable data as output port
 300               	.LM23:
 301 006a 93E0      		ldi r25,lo8(3)
 302 006c 94B9      		out 0x4,r25
 303               	.LBB63:
  41:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     for (int i = 0; i < 8; i++) {
 305               	.LM24:
 306 006e 20E0      		ldi r18,0
 307 0070 30E0      		ldi r19,0
  42:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         if (0x01 & (command >> (7-i))) {
 309               	.LM25:
 310 0072 90E0      		ldi r25,0
 311 0074 47E0      		ldi r20,lo8(7)
 312 0076 50E0      		ldi r21,0
  54:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             data_in;
 314               	.LM26:
 315 0078 EEEF      		ldi r30,lo8(-2)
 316               	.L15:
 317 007a BA01      		movw r22,r20
 318 007c 621B      		sub r22,r18
 319 007e 730B      		sbc r23,r19
  42:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         if (0x01 & (command >> (7-i))) {
 321               	.LM27:
 322 0080 DC01      		movw r26,r24
 323 0082 00C0      		rjmp 2f
 324               		1:
 325 0084 B595      		asr r27
 326 0086 A795      		ror r26
 327               		2:
 328 0088 6A95      		dec r22
 329 008a 02F4      		brpl 1b
 330 008c A0FF      		sbrs r26,0
 331 008e 00C0      		rjmp .L8
  43:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             data_high;
 333               	.LM28:
 334 0090 289A      		sbi 0x5,0
 335 0092 00C0      		rjmp .L9
 336               	.L8:
  45:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             data_low;
 338               	.LM29:
 339 0094 2898      		cbi 0x5,0
 340               	.L9:
 341               	.LBB64:
 342               	.LBB65:
 344               	.Ltext16:
 346               	.LM30:
 347 0096 BAE0      		ldi r27,lo8(10)
 348 0098 BA95      		1: dec r27
 349 009a 01F4      		brne 1b
 350 009c 00C0      		rjmp .
 351               	.LBE65:
 352               	.LBE64:
 354               	.Ltext17:
  49:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_high;
 356               	.LM31:
 357 009e 299A      		sbi 0x5,1
 358               	.LBB66:
 359               	.LBB67:
 361               	.Ltext18:
 363               	.LM32:
 364 00a0 6AE0      		ldi r22,lo8(10)
 365 00a2 6A95      		1: dec r22
 366 00a4 01F4      		brne 1b
 367 00a6 00C0      		rjmp .
 368               	.LBE67:
 369               	.LBE66:
 371               	.Ltext19:
  51:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_low;
 373               	.LM33:
 374 00a8 2998      		cbi 0x5,1
  53:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         if (i == 7) {
 376               	.LM34:
 377 00aa 2730      		cpi r18,7
 378 00ac 3105      		cpc r19,__zero_reg__
 379 00ae 01F0      		breq .L10
 380               	.L13:
  41:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     for (int i = 0; i < 8; i++) {
 382               	.LM35:
 383 00b0 2F5F      		subi r18,-1
 384 00b2 3F4F      		sbci r19,-1
 385 00b4 2830      		cpi r18,8
 386 00b6 3105      		cpc r19,__zero_reg__
 387 00b8 01F4      		brne .L15
 388               	.LBE63:
 389               	.LBB68:
 390               	.LBB69:
 392               	.Ltext20:
 394               	.LM36:
 395 00ba 8AE0      		ldi r24,lo8(10)
 396 00bc 8A95      		1: dec r24
 397 00be 01F4      		brne 1b
 398 00c0 00C0      		rjmp .
 399               	.LBE69:
 400               	.LBE68:
 402               	.Ltext21:
  61:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_high;
 404               	.LM37:
 405 00c2 299A      		sbi 0x5,1
 406               	.LBB70:
 407               	.LBB71:
 409               	.Ltext22:
 411               	.LM38:
 412 00c4 9AE0      		ldi r25,lo8(10)
 413 00c6 9A95      		1: dec r25
 414 00c8 01F4      		brne 1b
 415 00ca 00C0      		rjmp .
 416               	.LBE71:
 417               	.LBE70:
 419               	.Ltext23:
  63:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_low;
 421               	.LM39:
 422 00cc 2998      		cbi 0x5,1
 423 00ce 0895      		ret
 424               	.L10:
 425               	.LBB72:
  54:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             data_in;
 427               	.LM40:
 428 00d0 E4B9      		out 0x4,r30
  55:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             data_high;
 430               	.LM41:
 431 00d2 289A      		sbi 0x5,0
 432               	.L14:
  56:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             while ((PINB & (1 << DATA)));   // Wait for data line low
 434               	.LM42:
 435 00d4 1899      		sbic 0x3,0
 436 00d6 00C0      		rjmp .L14
 437 00d8 00C0      		rjmp .L13
 438               	.LBE72:
 446               	.Lscope3:
 448               	.global	reset
 450               	reset:
  66:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void reset() {
 452               	.LM43:
 453               	.LFBB4:
 454               	/* prologue: function */
 455               	/* frame size = 0 */
 456               	/* stack size = 0 */
 457               	.L__stack_usage = 0
  67:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_out;
 459               	.LM44:
 460 00da 83E0      		ldi r24,lo8(3)
 461 00dc 84B9      		out 0x4,r24
  68:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_high;
 463               	.LM45:
 464 00de 289A      		sbi 0x5,0
 465 00e0 89E0      		ldi r24,lo8(9)
 466 00e2 90E0      		ldi r25,0
 467               	.L22:
 468               	.LBB73:
 469               	.LBB74:
 470               	.LBB75:
 472               	.Ltext24:
 474               	.LM46:
 475 00e4 2AE0      		ldi r18,lo8(10)
 476 00e6 2A95      		1: dec r18
 477 00e8 01F4      		brne 1b
 478 00ea 00C0      		rjmp .
 479               	.LBE75:
 480               	.LBE74:
 482               	.Ltext25:
  72:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_high;
 484               	.LM47:
 485 00ec 299A      		sbi 0x5,1
 486               	.LBB76:
 487               	.LBB77:
 489               	.Ltext26:
 491               	.LM48:
 492 00ee 2AE0      		ldi r18,lo8(10)
 493 00f0 2A95      		1: dec r18
 494 00f2 01F4      		brne 1b
 495 00f4 00C0      		rjmp .
 496               	.LBE77:
 497               	.LBE76:
 499               	.Ltext27:
  74:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_low;
 501               	.LM49:
 502 00f6 2998      		cbi 0x5,1
 503 00f8 0197      		sbiw r24,1
  70:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     for (int i = 0; i < 9; i++) {
 505               	.LM50:
 506 00fa 0097      		sbiw r24,0
 507 00fc 01F4      		brne .L22
 508               	.LBE73:
  76:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     initialize_transmisson();
 510               	.LM51:
 511 00fe 0C94 0000 		jmp initialize_transmisson
 513               	.Lscope4:
 514               	.global	__floatunsisf
 515               	.global	__mulsf3
 516               	.global	__subsf3
 520               	.global	calculateMeasuredData
 522               	calculateMeasuredData:
 100:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** float calculateMeasuredData(uint16_t measuredData, uint8_t value) {
 524               	.LM52:
 525               	.LFBB5:
 526 0102 8F92      		push r8
 527 0104 9F92      		push r9
 528 0106 AF92      		push r10
 529 0108 BF92      		push r11
 530 010a CF92      		push r12
 531 010c DF92      		push r13
 532 010e EF92      		push r14
 533 0110 FF92      		push r15
 534               	/* prologue: function */
 535               	/* frame size = 0 */
 536               	/* stack size = 8 */
 537               	.L__stack_usage = 8
 103:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     switch (value) {
 539               	.LM53:
 540 0112 6330      		cpi r22,lo8(3)
 541 0114 01F0      		breq .L25
 542 0116 6530      		cpi r22,lo8(5)
 543 0118 01F4      		brne .L28
 544               	.LBB80:
 545               	.LBB81:
 105:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             humiLin = measuredData * 0.0405 - 2.8 * pow(10, -6) * pow(measuredData, 2) - 4;
 547               	.LM54:
 548 011a BC01      		movw r22,r24
 549 011c 80E0      		ldi r24,0
 550 011e 90E0      		ldi r25,0
 551 0120 0E94 0000 		call __floatunsisf
 552 0124 6B01      		movw r12,r22
 553 0126 7C01      		movw r14,r24
 554 0128 24E5      		ldi r18,lo8(84)
 555 012a 33EE      		ldi r19,lo8(-29)
 556 012c 45E2      		ldi r20,lo8(37)
 557 012e 5DE3      		ldi r21,lo8(61)
 558 0130 0E94 0000 		call __mulsf3
 559 0134 4B01      		movw r8,r22
 560 0136 5C01      		movw r10,r24
 561 0138 A701      		movw r20,r14
 562 013a 9601      		movw r18,r12
 563 013c C701      		movw r24,r14
 564 013e B601      		movw r22,r12
 565 0140 0E94 0000 		call __mulsf3
 566 0144 22EA      		ldi r18,lo8(-94)
 567 0146 37EE      		ldi r19,lo8(-25)
 568 0148 4BE3      		ldi r20,lo8(59)
 569 014a 56E3      		ldi r21,lo8(54)
 570 014c 0E94 0000 		call __mulsf3
 571 0150 9B01      		movw r18,r22
 572 0152 AC01      		movw r20,r24
 573 0154 C501      		movw r24,r10
 574 0156 B401      		movw r22,r8
 575 0158 0E94 0000 		call __subsf3
 576 015c 20E0      		ldi r18,0
 577 015e 30E0      		ldi r19,0
 578 0160 40E8      		ldi r20,lo8(-128)
 579 0162 50E4      		ldi r21,lo8(64)
 580 0164 00C0      		rjmp .L29
 581               	.L25:
 582               	.LBE81:
 583               	.LBE80:
 109:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             tempLin = -40.00 + 0.01 * measuredData;
 585               	.LM55:
 586 0166 BC01      		movw r22,r24
 587 0168 80E0      		ldi r24,0
 588 016a 90E0      		ldi r25,0
 589 016c 0E94 0000 		call __floatunsisf
 590 0170 2AE0      		ldi r18,lo8(10)
 591 0172 37ED      		ldi r19,lo8(-41)
 592 0174 43E2      		ldi r20,lo8(35)
 593 0176 5CE3      		ldi r21,lo8(60)
 594 0178 0E94 0000 		call __mulsf3
 595 017c 20E0      		ldi r18,0
 596 017e 30E0      		ldi r19,0
 597 0180 40E2      		ldi r20,lo8(32)
 598 0182 52E4      		ldi r21,lo8(66)
 599               	.L29:
 600 0184 0E94 0000 		call __subsf3
 110:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             return tempLin;
 602               	.LM56:
 603 0188 00C0      		rjmp .L24
 604               	.L28:
 114:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     return 1;
 606               	.LM57:
 607 018a 60E0      		ldi r22,0
 608 018c 70E0      		ldi r23,0
 609 018e 80E8      		ldi r24,lo8(-128)
 610 0190 9FE3      		ldi r25,lo8(63)
 611               	.L24:
 612               	/* epilogue start */
 115:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
 614               	.LM58:
 615 0192 FF90      		pop r15
 616 0194 EF90      		pop r14
 617 0196 DF90      		pop r13
 618 0198 CF90      		pop r12
 619 019a BF90      		pop r11
 620 019c AF90      		pop r10
 621 019e 9F90      		pop r9
 622 01a0 8F90      		pop r8
 623 01a2 0895      		ret
 625               	.Lscope5:
 627               	.global	serial_init
 629               	serial_init:
 118:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void serial_init() {
 631               	.LM59:
 632               	.LFBB6:
 633               	/* prologue: function */
 634               	/* frame size = 0 */
 635               	/* stack size = 0 */
 636               	.L__stack_usage = 0
 126:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     UCSR0B = (1 << TXEN0);
 638               	.LM60:
 639 01a4 88E0      		ldi r24,lo8(8)
 640 01a6 8093 C100 		sts 193,r24
 127:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     UBRR0L = 51;
 642               	.LM61:
 643 01aa 83E3      		ldi r24,lo8(51)
 644 01ac 8093 C400 		sts 196,r24
 128:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
 646               	.LM62:
 647 01b0 86E0      		ldi r24,lo8(6)
 648 01b2 8093 C200 		sts 194,r24
 649 01b6 0895      		ret
 651               	.Lscope6:
 654               	.global	receiveBytes
 656               	receiveBytes:
 139:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
 140:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void receiveBytes(uint8_t *target) {
 658               	.LM63:
 659               	.LFBB7:
 660               	/* prologue: function */
 661               	/* frame size = 0 */
 662               	/* stack size = 0 */
 663               	.L__stack_usage = 0
 664 01b8 FC01      		movw r30,r24
 666               	.LM64:
 667 01ba 27E0      		ldi r18,lo8(7)
 668 01bc 30E0      		ldi r19,0
 669               	.LBB82:
 141:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     for (int i = 0; i < 8; i++) {
 142:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_high;
 143:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         _delay_us(4);
 144:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         if ((PINB & (1 << PINB0))) {
 145:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             *target |= (1 << (7 - i));
 146:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         } else {
 147:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             *target &= ~(1 << (7 - i));
 671               	.LM65:
 672 01be 81E0      		ldi r24,lo8(1)
 673 01c0 90E0      		ldi r25,0
 674               	.L35:
 142:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_high;
 676               	.LM66:
 677 01c2 299A      		sbi 0x5,1
 678               	.LBB83:
 679               	.LBB84:
 681               	.Ltext28:
 683               	.LM67:
 684 01c4 4AE0      		ldi r20,lo8(10)
 685 01c6 4A95      		1: dec r20
 686 01c8 01F4      		brne 1b
 687 01ca 00C0      		rjmp .
 688 01cc 6081      		ld r22,Z
 689               	.LBE84:
 690               	.LBE83:
 692               	.Ltext29:
 145:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             *target |= (1 << (7 - i));
 694               	.LM68:
 695 01ce AC01      		movw r20,r24
 696 01d0 022E      		mov r0,r18
 697 01d2 00C0      		rjmp 2f
 698               		1:
 699 01d4 440F      		lsl r20
 700               		2:
 701 01d6 0A94      		dec r0
 702 01d8 02F4      		brpl 1b
 144:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         if ((PINB & (1 << PINB0))) {
 704               	.LM69:
 705 01da 189B      		sbis 0x3,0
 706 01dc 00C0      		rjmp .L32
 145:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             *target |= (1 << (7 - i));
 708               	.LM70:
 709 01de 462B      		or r20,r22
 710 01e0 00C0      		rjmp .L36
 711               	.L32:
 713               	.LM71:
 714 01e2 4095      		com r20
 715 01e4 4623      		and r20,r22
 716               	.L36:
 717 01e6 4083      		st Z,r20
 148:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         }
 149:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         sck_low;
 719               	.LM72:
 720 01e8 2998      		cbi 0x5,1
 721               	.LBB85:
 722               	.LBB86:
 724               	.Ltext30:
 726               	.LM73:
 727 01ea 4AE0      		ldi r20,lo8(10)
 728 01ec 4A95      		1: dec r20
 729 01ee 01F4      		brne 1b
 730 01f0 00C0      		rjmp .
 731               	.LBE86:
 732               	.LBE85:
 733 01f2 2150      		subi r18,1
 734 01f4 3109      		sbc r19,__zero_reg__
 735 01f6 00F4      		brcc .L35
 736               	/* epilogue start */
 737               	.LBE82:
 739               	.Ltext31:
 150:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****         _delay_us(4);
 151:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     }
 152:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
 741               	.LM74:
 742 01f8 0895      		ret
 744               	.Lscope7:
 746               	.global	ack
 748               	ack:
 153:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** 
 154:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** void ack(void) {
 750               	.LM75:
 751               	.LFBB8:
 752               	/* prologue: function */
 753               	/* frame size = 0 */
 754               	/* stack size = 0 */
 755               	.L__stack_usage = 0
 155:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_out;
 757               	.LM76:
 758 01fa 83E0      		ldi r24,lo8(3)
 759 01fc 84B9      		out 0x4,r24
 156:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_low;
 761               	.LM77:
 762 01fe 2898      		cbi 0x5,0
 763               	.LBB87:
 764               	.LBB88:
 766               	.Ltext32:
 768               	.LM78:
 769 0200 8AE0      		ldi r24,lo8(10)
 770 0202 8A95      		1: dec r24
 771 0204 01F4      		brne 1b
 772 0206 00C0      		rjmp .
 773               	.LBE88:
 774               	.LBE87:
 776               	.Ltext33:
 157:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(4);
 158:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_high;
 778               	.LM79:
 779 0208 299A      		sbi 0x5,1
 780               	.LBB89:
 781               	.LBB90:
 783               	.Ltext34:
 785               	.LM80:
 786 020a 8AE0      		ldi r24,lo8(10)
 787 020c 8A95      		1: dec r24
 788 020e 01F4      		brne 1b
 789 0210 00C0      		rjmp .
 790               	.LBE90:
 791               	.LBE89:
 793               	.Ltext35:
 159:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(4);
 160:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     sck_low;
 795               	.LM81:
 796 0212 2998      		cbi 0x5,1
 797               	.LBB91:
 798               	.LBB92:
 800               	.Ltext36:
 802               	.LM82:
 803 0214 8AE0      		ldi r24,lo8(10)
 804 0216 8A95      		1: dec r24
 805 0218 01F4      		brne 1b
 806 021a 00C0      		rjmp .
 807               	.LBE92:
 808               	.LBE91:
 810               	.Ltext37:
 161:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     _delay_us(4);
 162:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_in;
 812               	.LM83:
 813 021c 8EEF      		ldi r24,lo8(-2)
 814 021e 84B9      		out 0x4,r24
 163:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_high;
 816               	.LM84:
 817 0220 289A      		sbi 0x5,0
 818 0222 0895      		ret
 820               	.Lscope8:
 822               	.global	read_data
 824               	read_data:
  81:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** uint16_t read_data() {
 826               	.LM85:
 827               	.LFBB9:
 828 0224 CF93      		push r28
 829 0226 DF93      		push r29
 830 0228 00D0      		rcall .
 831 022a CDB7      		in r28,__SP_L__
 832 022c DEB7      		in r29,__SP_H__
 833               	/* prologue: function */
 834               	/* frame size = 2 */
 835               	/* stack size = 4 */
 836               	.L__stack_usage = 4
  84:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     dataL = 0x00;
 838               	.LM86:
 839 022e 1A82      		std Y+2,__zero_reg__
  85:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     dataH = 0x00;
 841               	.LM87:
 842 0230 1982      		std Y+1,__zero_reg__
  86:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_in;
 844               	.LM88:
 845 0232 8EEF      		ldi r24,lo8(-2)
 846 0234 84B9      		out 0x4,r24
  87:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     data_high;
 848               	.LM89:
 849 0236 289A      		sbi 0x5,0
 850               	.L40:
  89:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     while (PINB & (1<<DATA));
 852               	.LM90:
 853 0238 1899      		sbic 0x3,0
 854 023a 00C0      		rjmp .L40
  91:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     receiveBytes(&dataH);
 856               	.LM91:
 857 023c CE01      		movw r24,r28
 858 023e 0196      		adiw r24,1
 859 0240 0E94 0000 		call receiveBytes
  92:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     ack(); // ack() to start getting LSB
 861               	.LM92:
 862 0244 0E94 0000 		call ack
  94:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     receiveBytes(&dataL);
 864               	.LM93:
 865 0248 CE01      		movw r24,r28
 866 024a 0296      		adiw r24,2
 867 024c 0E94 0000 		call receiveBytes
  96:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****     measured = (dataH << 8) | dataL;
 869               	.LM94:
 870 0250 8981      		ldd r24,Y+1
 871 0252 90E0      		ldi r25,0
 872 0254 982F      		mov r25,r24
 873 0256 8827      		clr r24
 874 0258 2A81      		ldd r18,Y+2
  98:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c **** }
 876               	.LM95:
 877 025a 822B      		or r24,r18
 878               	/* epilogue start */
 879 025c 0F90      		pop __tmp_reg__
 880 025e 0F90      		pop __tmp_reg__
 881 0260 DF91      		pop r29
 882 0262 CF91      		pop r28
 883 0264 0895      		ret
 889               	.Lscope9:
 890               	.global	__addsf3
 891               		.section	.rodata.str1.1,"aMS",@progbits,1
 892               	.LC0:
 893 0000 4875 6D69 		.string	"Humidity: %.2f (Compansated: %.2f) Temp: %.2f \n"
 893      6469 7479 
 893      3A20 252E 
 893      3266 2028 
 893      436F 6D70 
 894               		.section	.text.startup,"ax",@progbits
 896               	.global	main
 898               	main:
 900               	.Ltext38:
   1:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** /*
   2:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****  *
   3:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****  * [Atmega328p - SHT11]
   4:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****  * Temperature & Humidity Measurement Application
   5:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****  * Author: aercys
   6:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****  * E-Mail: aercys@gmail.com
   7:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****  * Web: i2xr.com
   8:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****  * Date: 10/03/2015
   9:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****  *
  10:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****  */
  11:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** 
  12:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** 
  13:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** 
  14:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** #include <stdio.h>
  15:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** #include <avr/io.h>
  16:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** #include <avr/interrupt.h>
  17:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** #include <util/delay.h>
  18:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** #include <math.h>
  19:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** #include "sht/sht.h"
  20:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** #include "sht/sht.c"
  21:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** 
  22:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** 
  23:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c **** int main(void) {
 902               	.LM96:
 903               	.LFBB10:
 904               	/* prologue: function */
 905               	/* frame size = 0 */
 906               	/* stack size = 0 */
 907               	.L__stack_usage = 0
 908               	.LBB109:
 909               	.LBB110:
 911               	.Ltext39:
 913               	.LM97:
 914 0000 2DE1      		ldi r18,lo8(29)
 915 0002 2A95      		1: dec r18
 916 0004 01F4      		brne 1b
 917 0006 0000      		nop
 918               	.LBE110:
 919               	.LBE109:
 921               	.Ltext40:
  24:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     
  25:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     float humidity_data, humidity_data_com, temperature_data;
  26:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     uint16_t humidityLin;
  27:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     
  28:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     _delay_us(11);                  // Wait for sensor initialization
  29:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     
  30:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     serial_init();
 923               	.LM98:
 924 0008 0E94 0000 		call serial_init
  31:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     stdout = &uart_output;
 926               	.LM99:
 927 000c 80E0      		ldi r24,lo8(uart_output)
 928 000e 90E0      		ldi r25,hi8(uart_output)
 929 0010 9093 0000 		sts __iob+2+1,r25
 930 0014 8093 0000 		sts __iob+2,r24
  32:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     
  33:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****     while (1) {
  34:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         initialize_transmisson();   // Initilize the sensor to send command
  35:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         send_command(temperature);
  36:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         _delay_us(80);              // Wait for measurement to complete
  37:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         temperature_data = calculateMeasuredData(read_data(), temperature);
  38:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         reset();
  39:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         send_command(humidity);
  40:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         _delay_us(80);
  41:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         humidityLin = read_data();
  42:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         humidity_data = calculateMeasuredData(humidityLin, humidity);
  43:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         humidity_data_com = (temperature_data - 25) * (0.01 + 0.00008 * humidityLin) + humidity_dat
  44:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         printf("Humidity: %.2f (Compansated: %.2f) Temp: %.2f \n",
 932               	.LM100:
 933 0018 C0E0      		ldi r28,lo8(.LC0)
 934 001a D0E0      		ldi r29,hi8(.LC0)
 935               	.L42:
  34:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         initialize_transmisson();   // Initilize the sensor to send command
 937               	.LM101:
 938 001c 0E94 0000 		call initialize_transmisson
  35:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         send_command(temperature);
 940               	.LM102:
 941 0020 83E0      		ldi r24,lo8(3)
 942 0022 0E94 0000 		call send_command
 943               	.LBB111:
 944               	.LBB112:
 946               	.Ltext41:
 948               	.LM103:
 949 0026 85ED      		ldi r24,lo8(-43)
 950 0028 8A95      		1: dec r24
 951 002a 01F4      		brne 1b
 952 002c 0000      		nop
 953               	.LBE112:
 954               	.LBE111:
 956               	.Ltext42:
  37:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         temperature_data = calculateMeasuredData(read_data(), temperature);
 958               	.LM104:
 959 002e 0E94 0000 		call read_data
 960               	.LBB113:
 961               	.LBB114:
 963               	.Ltext43:
 109:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             tempLin = -40.00 + 0.01 * measuredData;
 965               	.LM105:
 966 0032 BC01      		movw r22,r24
 967 0034 80E0      		ldi r24,0
 968 0036 90E0      		ldi r25,0
 969 0038 0E94 0000 		call __floatunsisf
 970 003c 2AE0      		ldi r18,lo8(10)
 971 003e 37ED      		ldi r19,lo8(-41)
 972 0040 43E2      		ldi r20,lo8(35)
 973 0042 5CE3      		ldi r21,lo8(60)
 974 0044 0E94 0000 		call __mulsf3
 975 0048 20E0      		ldi r18,0
 976 004a 30E0      		ldi r19,0
 977 004c 40E2      		ldi r20,lo8(32)
 978 004e 52E4      		ldi r21,lo8(66)
 979 0050 0E94 0000 		call __subsf3
 980 0054 1B01      		movw r2,r22
 981 0056 2C01      		movw r4,r24
 982               	.LBE114:
 983               	.LBE113:
 985               	.Ltext44:
  38:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         reset();
 987               	.LM106:
 988 0058 0E94 0000 		call reset
  39:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         send_command(humidity);
 990               	.LM107:
 991 005c 85E0      		ldi r24,lo8(5)
 992 005e 0E94 0000 		call send_command
 993               	.LBB115:
 994               	.LBB116:
 996               	.Ltext45:
 998               	.LM108:
 999 0062 95ED      		ldi r25,lo8(-43)
 1000 0064 9A95      		1: dec r25
 1001 0066 01F4      		brne 1b
 1002 0068 0000      		nop
 1003               	.LBE116:
 1004               	.LBE115:
 1006               	.Ltext46:
  41:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         humidityLin = read_data();
 1008               	.LM109:
 1009 006a 0E94 0000 		call read_data
 1010               	.LBB117:
 1011               	.LBB118:
 1012               	.LBB119:
 1013               	.LBB120:
 1015               	.Ltext47:
 105:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/sht/sht.c ****             humiLin = measuredData * 0.0405 - 2.8 * pow(10, -6) * pow(measuredData, 2) - 4;
 1017               	.LM110:
 1018 006e BC01      		movw r22,r24
 1019 0070 80E0      		ldi r24,0
 1020 0072 90E0      		ldi r25,0
 1021 0074 0E94 0000 		call __floatunsisf
 1022 0078 4B01      		movw r8,r22
 1023 007a 5C01      		movw r10,r24
 1024 007c 24E5      		ldi r18,lo8(84)
 1025 007e 33EE      		ldi r19,lo8(-29)
 1026 0080 45E2      		ldi r20,lo8(37)
 1027 0082 5DE3      		ldi r21,lo8(61)
 1028 0084 0E94 0000 		call __mulsf3
 1029 0088 6B01      		movw r12,r22
 1030 008a 7C01      		movw r14,r24
 1031 008c A501      		movw r20,r10
 1032 008e 9401      		movw r18,r8
 1033 0090 C501      		movw r24,r10
 1034 0092 B401      		movw r22,r8
 1035 0094 0E94 0000 		call __mulsf3
 1036 0098 22EA      		ldi r18,lo8(-94)
 1037 009a 37EE      		ldi r19,lo8(-25)
 1038 009c 4BE3      		ldi r20,lo8(59)
 1039 009e 56E3      		ldi r21,lo8(54)
 1040 00a0 0E94 0000 		call __mulsf3
 1041 00a4 9B01      		movw r18,r22
 1042 00a6 AC01      		movw r20,r24
 1043 00a8 C701      		movw r24,r14
 1044 00aa B601      		movw r22,r12
 1045 00ac 0E94 0000 		call __subsf3
 1046 00b0 20E0      		ldi r18,0
 1047 00b2 30E0      		ldi r19,0
 1048 00b4 40E8      		ldi r20,lo8(-128)
 1049 00b6 50E4      		ldi r21,lo8(64)
 1050 00b8 0E94 0000 		call __subsf3
 1051 00bc 162F      		mov r17,r22
 1052 00be 072F      		mov r16,r23
 1053 00c0 782E      		mov r7,r24
 1054 00c2 692E      		mov r6,r25
 1055               	.LBE120:
 1056               	.LBE119:
 1057               	.LBE118:
 1058               	.LBE117:
 1060               	.Ltext48:
 1062               	.LM111:
 1063 00c4 5F92      		push r5
 1064 00c6 4F92      		push r4
 1065 00c8 3F92      		push r3
 1066 00ca 2F92      		push r2
  43:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         humidity_data_com = (temperature_data - 25) * (0.01 + 0.00008 * humidityLin) + humidity_dat
 1068               	.LM112:
 1069 00cc 20E0      		ldi r18,0
 1070 00ce 30E0      		ldi r19,0
 1071 00d0 48EC      		ldi r20,lo8(-56)
 1072 00d2 51E4      		ldi r21,lo8(65)
 1073 00d4 622D      		mov r22,r2
 1074 00d6 732D      		mov r23,r3
 1075 00d8 842D      		mov r24,r4
 1076 00da 952D      		mov r25,r5
 1077 00dc 0E94 0000 		call __subsf3
 1078 00e0 6B01      		movw r12,r22
 1079 00e2 7C01      		movw r14,r24
 1080 00e4 2CEA      		ldi r18,lo8(-84)
 1081 00e6 35EC      		ldi r19,lo8(-59)
 1082 00e8 47EA      		ldi r20,lo8(-89)
 1083 00ea 58E3      		ldi r21,lo8(56)
 1084 00ec C501      		movw r24,r10
 1085 00ee B401      		movw r22,r8
 1086 00f0 0E94 0000 		call __mulsf3
 1087 00f4 2AE0      		ldi r18,lo8(10)
 1088 00f6 37ED      		ldi r19,lo8(-41)
 1089 00f8 43E2      		ldi r20,lo8(35)
 1090 00fa 5CE3      		ldi r21,lo8(60)
 1091 00fc 0E94 0000 		call __addsf3
 1092 0100 9B01      		movw r18,r22
 1093 0102 AC01      		movw r20,r24
 1094 0104 C701      		movw r24,r14
 1095 0106 B601      		movw r22,r12
 1096 0108 0E94 0000 		call __mulsf3
 1097 010c D801      		movw r26,r16
 1098 010e F301      		movw r30,r6
 1099 0110 2B2F      		mov r18,r27
 1100 0112 3A2F      		mov r19,r26
 1101 0114 4F2F      		mov r20,r31
 1102 0116 5E2F      		mov r21,r30
 1103 0118 0E94 0000 		call __addsf3
 1105               	.LM113:
 1106 011c 9F93      		push r25
 1107 011e 8F93      		push r24
 1108 0120 7F93      		push r23
 1109 0122 6F93      		push r22
 1110 0124 6F92      		push r6
 1111 0126 7F92      		push r7
 1112 0128 0F93      		push r16
 1113 012a 1F93      		push r17
 1114 012c DF93      		push r29
 1115 012e CF93      		push r28
 1116 0130 0E94 0000 		call printf
  45:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****                (double)humidity_data, (double)humidity_data_com, (double)temperature_data);
  46:/Users/atakane/Documents/Electronics/avrSHT/avrSHT/main.c ****         reset();
 1118               	.LM114:
 1119 0134 0E94 0000 		call reset
 1120               	.LBB121:
 1121               	.LBB122:
 1123               	.Ltext49:
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1125               	.LM115:
 1126 0138 9FEF      		ldi r25,lo8(1599999)
 1127 013a 29E6      		ldi r18,hi8(1599999)
 1128 013c 88E1      		ldi r24,hlo8(1599999)
 1129 013e 9150      		1: subi r25,1
 1130 0140 2040      		sbci r18,0
 1131 0142 8040      		sbci r24,0
 1132 0144 01F4      		brne 1b
 1133 0146 00C0      		rjmp .
 1134 0148 0000      		nop
 1135 014a 8DB7      		in r24,__SP_L__
 1136 014c 9EB7      		in r25,__SP_H__
 1137 014e 0E96      		adiw r24,14
 1138 0150 0FB6      		in __tmp_reg__,__SREG__
 1139 0152 F894      		cli
 1140 0154 9EBF      		out __SP_H__,r25
 1141 0156 0FBE      		out __SREG__,__tmp_reg__
 1142 0158 8DBF      		out __SP_L__,r24
 1143 015a 00C0      		rjmp .L42
 1144               	.LBE122:
 1145               	.LBE121:
 1150               	.Lscope10:
 1151               	.global	uart_output
 1152               		.data
 1155               	uart_output:
 1156 0000 0000 00   		.zero	3
 1157 0003 02        		.byte	2
 1158 0004 0000 0000 		.zero	4
 1159 0008 0000      		.word	gs(send_uart_char)
 1160 000a 0000      		.word	0
 1161 000c 0000      		.word	0
 1163               		.text
 1165               	.Letext0:
 1166               		.ident	"GCC: (GNU) 4.8.1"
 1167               	.global __do_copy_data
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:2      *ABS*:0000003e __SP_H__
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:3      *ABS*:0000003d __SP_L__
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:4      *ABS*:0000003f __SREG__
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:6      *ABS*:00000001 __zero_reg__
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:114    .text:00000000 send_uart_char
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:153    .text:0000001e initialize_transmisson
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:277    .text:00000062 send_command
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:450    .text:000000da reset
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:522    .text:00000102 calculateMeasuredData
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:629    .text:000001a4 serial_init
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:656    .text:000001b8 receiveBytes
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:748    .text:000001fa ack
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:824    .text:00000224 read_data
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:898    .text.startup:00000000 main
/var/folders/2t/x0mw6nss4_z3npyvmny7gnnm0000gn/T//ccEpbRMJ.s:1155   .data:00000000 uart_output

UNDEFINED SYMBOLS
__floatunsisf
__mulsf3
__subsf3
__addsf3
__iob
printf
__do_copy_data
